<!DOCTYPE html><html><head>
      <title>final</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#000;background:0 0;text-shadow:0 1px #fff;font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:#b3d4fc}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#a67f59;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="final-report-j_score">Final report: J_score </h1>
<p>Maximilian Fernaldy - C2TB1702</p>
<br>
<p>The objective of the final assignment is to display a ranked results sheet of the 2023 J-league season. We are provided with a csv (comma-separated values) file detailing the result of each team, and we are tasked to add two additional statistics, rank the teams based on their results, and display the ranked order along with the statistics in a .txt file. This is an exercise in database construction, manipulation and display, and a little glimpse into Data Structures and Algorithm, too, namely in the optional tasks.</p>
<p>Mostly, the flow of execution in both J_score1.c and J_score2.c is the same:</p>
<ol>
<li>Read data from the provided .csv file</li>
<li>Store the data in an array of structs</li>
<li>Assign points and calculate goal difference for each team</li>
<li>Rank the teams based on points, goal difference and goals scored as the final tiebreaker</li>
<li>Write the ranked data to a .txt file and format it for readability</li>
</ol>
<p>However, the methods that the two programs use to execute two of these tasks are different. First of all, J_score1.c employs a simple selection sort to sort the teams in order, while J_score2.c uses a smarter heap sort algorithm. Secondly, J_score1.c works directly with the array, moving entire structs around each time a swap is performed for the sorting algorithm. On the contrary, J_score2.c sorts an array of pointers to the structs instead, which are much smaller than the structs they point to, and as a consequence, are easier to move around. For a short list with 18 members like this case, the difference might not be very noticeable, but for large databases with thousands of entries, each of them structs containing a considerable amount of data, the difference will be very noticeable. I will demonstrate this difference later.</p>
<h2 id="1-common-operation-between-j_score1c-and-j_score2c">1. Common operation between J_score1.c and J_score2.c </h2>
<p>For tasks 1 to 3, J_score1.c and J_score2.c performs identically. First, we read the data from J_result2023.csv using read_data. Originally, <code>read_data()</code> takes the file pointer from the main function and writes the data to a table also declared in the main function. At first I used this approach, but this makes modifying the csv file difficult. If an entry is added to the csv file, the program breaks because a macro definition is used to define the number of teams in the file (<code>#define TEAM_NUM 18</code>), and this macro definition is used to define the size of <code>table[]</code>. In my opinion, the number of teams should be determined by the reading function <code>read_data()</code>, then memory allocation is done dynamically according to how many teams there are. This means the program can be used with any csv file as long as the format is correct, regardless of the number of teams in the file.</p>
<h3 id="a-counting-the-number-of-teams-in-the-file">a). Counting the number of teams in the file </h3>
<p>It is possible to count the number of teams in the file <em>and</em> reading data from it in one pass through the file, but according to resources online, using two <code>while</code> loops; first to count the number of teams and second to read data, is a more common and maintainable approach. Since the time complexity is still O(n), we don't have to worry about performance issues. To implement this, I created a function <code>get_number_of_teams()</code> to count the number of teams in the file.</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code><span class="token keyword keyword-int">int</span> <span class="token function">get_number_of_teams</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>fin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// This function gets the selected file and returns how many lines are in the file.</span>
    <span class="token keyword keyword-char">char</span> buffer<span class="token punctuation">[</span>DATA_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> number_of_teams <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> fin<span class="token punctuation">)</span> <span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        number_of_teams<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">fseek</span><span class="token punctuation">(</span>fin<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// return fgets to the first line</span>
    <span class="token keyword keyword-return">return</span> number_of_teams<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>This function simply loops and increments <code>number_of_teams</code> until <code>fgets()</code> returns <code>NULL</code>, which means there are no more non-empty lines in the file. Then at the end of the loop it returns <code>number_of_teams</code>.</p>
<h3 id="b-reading-and-storing-data">b). Reading and storing data </h3>
<p>The <code>get_number_of_teams()</code> function is called inside <code>read_data()</code>, which allocates memory according to how many teams there are in the file, and executes another <code>while</code> loop to read the data and store it inside <code>table[]</code>:</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code>SC <span class="token operator">*</span><span class="token function">read_data</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>file_path<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> <span class="token operator">*</span>number_of_teams<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Read data from csv file and store in table[]</span>
    <span class="token comment">// Declare table to store data</span>
    SC <span class="token operator">*</span>table<span class="token punctuation">;</span>

    <span class="token comment">// Open file for reading</span>
    FILE <span class="token operator">*</span>fin<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fin <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>file_path<span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// open input file</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Can't open result file. Make sure the csv file is in the working directory and formatted as \"J_resultYYYY.csv\".\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Reading file \"%s\"...\n"</span><span class="token punctuation">,</span> file_path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Dynamically allocate memory for table</span>
    <span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>number_of_teams <span class="token operator">=</span> <span class="token function">get_number_of_teams</span><span class="token punctuation">(</span>fin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    table <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>SC<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token operator">*</span>number_of_teams<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> buffer<span class="token punctuation">[</span>DATA_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> fin<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">sscanf</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token string">"%[^,],%d,%d,%d,%d,%d"</span><span class="token punctuation">,</span>
                table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>
                <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>win<span class="token punctuation">,</span>
                <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>draw<span class="token punctuation">,</span>
                <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>loss<span class="token punctuation">,</span>
                <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>GF<span class="token punctuation">,</span>
                <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>GA<span class="token punctuation">)</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">fclose</span><span class="token punctuation">(</span>fin<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-return">return</span> table<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>In <code>read_data()</code>, the while loop is almost the same as <code>get_number_of_teams()</code>, but this time, the buffer is scanned and stored with <code>sscanf()</code>. One thing to note, the arguments of <code>sscanf()</code> are:</p>
<ol>
<li>The buffer to read from</li>
<li>The format of the string used to scan the buffer</li>
<li>The <strong>memory addresses</strong> to store the data in</li>
</ol>
<p>Since it takes <strong>memory addresses</strong>, we need to use the ampersand (&amp;) operator in front of the variable members. However, this does not apply to <code>table[i].name</code> (the team name), because recall that in C, strings are arrays of characters. This means <code>table[i].name</code> is actually a pointer to the first character of the string. We don't need to take the memory address of that again, because then it would become the memory address of the pointer instead.</p>
<p>It might feel bulky to move the entire table from the <code>read_data()</code> function to the main function, but in fact, we are only returning the <em>pointer</em> to the table. There is no copying of large data here, we are only building the data as we would normally and telling the main function where that data is stored.</p>
<h3 id="c-assigning-points-and-calculating-goal-difference-for-each-team">c). Assigning points and calculating goal difference for each team </h3>
<p>If we imagine the array of structs as a table (conveniently, the array is literally named <code>table[]</code>), then the rows represent different teams, and the columns represent the members of the struct. Then we can visualize this operation as the function being passed a single row of the table and writing the results of the calculation into two columns.</p>
<p align="center"> <img src="./assets/calc_score_annotated.png" width="75%"> </p>
<p>The fields colored in yellow are already given to us, but we still need to fill in the points and goal difference for each team in our imaginary table—the fields in red. This is done by passing the pointer to each team's data into a function that does the calculation and writes the result back into the correct fields. This pointer is declared as <code>SC *team</code>: a pointer to an SC-type variable. Since what we have is a pointer to a struct, we can use the arrow operator to access and write to the members:</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code><span class="token keyword keyword-void">void</span> <span class="token function">calc_score</span><span class="token punctuation">(</span>SC <span class="token operator">*</span>team<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Points = wins * 3 + draws * 1 + losses * 0</span>
    team<span class="token operator">-&gt;</span>score <span class="token operator">=</span> team<span class="token operator">-&gt;</span>win <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> team<span class="token operator">-&gt;</span>draw<span class="token punctuation">;</span>
    <span class="token comment">// Point difference = Goals For - Goals Against</span>
    team<span class="token operator">-&gt;</span>point_diff <span class="token operator">=</span> team<span class="token operator">-&gt;</span>GF <span class="token operator">-</span> team<span class="token operator">-&gt;</span>GA<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>This is done for every team by iterating through all of them in the main function and passing the correct pointer for each one.</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code><span class="token comment">/* （2）Calculating score */</span>
<span class="token keyword keyword-for">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> number_of_teams<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">calc_score</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="2-j_score1c">2. J_score1.c </h2>
<p>With the points and goal difference calculations done, we can move on to ranking the teams. This is where J_score1.c and J_score2.c starts to diverge in their methodology. First we will look at how J_score1.c ranks the teams: using a simple selection sort.</p>
<h3 id="a-what-is-selection-sort">a). What is selection sort? </h3>
<p>Selection sort is a simple sorting algorithm that works by going through the entire unsorted portion, finding the largest or smallest element, then "moving" it from the unsorted portion to the sorted portion by swapping it with the first element in the unsorted portion. The first iteration compares the first element with all other elements <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, the second with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> elements, and so on, until the second last element is compared only once with the last unsorted element. Each iteration, the unsorted portion decreases by 1, so the total number of required comparisons is:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mo>…</mo><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">(n-1) + (n-2) + \ldots + 2 + 1 = \frac{n(n-1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>Since we drop constants and only take the largest order for big O notation, the time complexity is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. Big O notation is usually taken for the worst case scenario, but for selection sort, this is actually true for <strong>all cases.</strong> This is because no matter what the sequence of numbers looks like, it will always look through the entire array for the smallest or largest element. A time complexity of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is definitely not the best for large databases, but it doesn't mean selection sort is useless. It's still plenty fast enough for small lists or small data types, and its tiny code size and simplicity are valid strengths over its more complicated counterparts.</p>
<h3 id="b-implementing-selection-sort-in-j_score1c">b). Implementing selection sort in J_score1.c </h3>
<p>Selection sort is very simple to implement. We simply have two <code>for</code> loops, one to iterate from the first element to the second last as the reference elements, and the second nested inside the first one to iterate from the element <em>after</em> the reference element to the very last element in the array, as the compared elements. This is where the time complexity <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> comes from: there are two loops each iterating through (basically) the entire array.</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code><span class="token keyword keyword-void">void</span> <span class="token function">rank_score</span><span class="token punctuation">(</span>SC table<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> number_of_teams<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Use selection sort</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> number_of_teams<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-int">int</span> highest_rank_index <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> number_of_teams<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// SORTING CONDITIONS</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>highest_rank_index <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">swap_SC</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>highest_rank_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>If we ignore the <code>if-else</code> ladder for our sorting conditions for a moment, the code is actually very small and easy to understand. It's just two nested loops and a swap at the end of the <code>i</code> loop if a new highest rank is found.</p>
<p>As for the <code>if-else</code> ladder itself,</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>table<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>score <span class="token operator">&gt;</span> table<span class="token punctuation">[</span>highest_rank_index<span class="token punctuation">]</span><span class="token punctuation">.</span>score<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    highest_rank_index <span class="token operator">=</span> j<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>table<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>score <span class="token operator">==</span> table<span class="token punctuation">[</span>highest_rank_index<span class="token punctuation">]</span><span class="token punctuation">.</span>score<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Case if a score tie is encountered</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>table<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>point_diff <span class="token operator">&gt;</span> table<span class="token punctuation">[</span>highest_rank_index<span class="token punctuation">]</span><span class="token punctuation">.</span>point_diff<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// If compared team has larger point difference</span>
        highest_rank_index <span class="token operator">=</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>table<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>point_diff <span class="token operator">==</span> table<span class="token punctuation">[</span>highest_rank_index<span class="token punctuation">]</span><span class="token punctuation">.</span>point_diff<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// If the point difference is still the same</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>table<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>GF <span class="token operator">&gt;</span> table<span class="token punctuation">[</span>highest_rank_index<span class="token punctuation">]</span><span class="token punctuation">.</span>GF<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// If the compared team has more goals scored.</span>
            highest_rank_index <span class="token operator">=</span> j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>If a team's score is simply higher than the previously highest score, the highest rank index is reassigned. Then if a tie is encountered, the ladder checks if the compared team's <em>point difference</em> is larger. If it's still a tie, the ladder checks if the compared team has more goals scored than the previous highest. If even the goals scored is a tie, the program leaves it alone, as it is not in the specifications of the assignment.</p>
<p>Once all the comparisons are done, if a new highest rank is found, we swap the positions of the two teams in the array with <code>swap_SC()</code>:</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code><span class="token keyword keyword-void">void</span> <span class="token function">swap_SC</span><span class="token punctuation">(</span>SC <span class="token operator">*</span>team1<span class="token punctuation">,</span> SC <span class="token operator">*</span>team2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Swap places of reference team and team with current highest score</span>
    SC temp <span class="token operator">=</span> <span class="token operator">*</span>team1<span class="token punctuation">;</span>
    <span class="token operator">*</span>team1 <span class="token operator">=</span> <span class="token operator">*</span>team2<span class="token punctuation">;</span>
    <span class="token operator">*</span>team2 <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>We can already get a sense of how bulky this program feels: it takes the pointer to two teams, copies the <strong>entire struct</strong> to a temporary variable <code>temp</code>, copies the whole of <code>team2</code> to <code>team1</code>, then copies the whole of <code>temp</code> to <code>team2</code> again. Now, <code>team_score</code> is a relatively small struct of 1 <code>char[20]</code> and 7 <code>int</code>'s, so its size is probably around 32 bytes with padding. But imagine using this method for moving structs that are much larger. We can see how efficient data structures and algorithms are so important when moving actual real world data.</p>
<h3 id="c-displaying-the-ranked-data-to-a-txt-file-for-j_score1c">c). Displaying the ranked data to a .txt file for J_score1.c </h3>
<p>If there is an upside to dealing with sorting the data directly, it is that displaying the sorted data is very easy. The array <code>table[]</code> is already in order, and we only need to iterate through them and print them line by line to a text file, like how we would with <code>printf()</code>.</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code><span class="token keyword keyword-void">void</span> <span class="token function">write_data</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>fout<span class="token punctuation">,</span> SC table<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> number_of_teams<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span>fout<span class="token punctuation">,</span> <span class="token string">"| Rank | Team Name            | Wins | Draws | Losses | Goals Scored | Goals Conceded | Points | Goal Difference |\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span>fout<span class="token punctuation">,</span> <span class="token string">"|------|----------------------|------|-------|--------|--------------|----------------|--------|-----------------|\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> number_of_teams<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span>fout<span class="token punctuation">,</span> <span class="token string">"| %-4d | %-20s | %4d | %5d | %6d | %12d | %14d | %6d | %15d |\n"</span><span class="token punctuation">,</span>
                i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>
                table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>
                table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>win<span class="token punctuation">,</span>
                table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>draw<span class="token punctuation">,</span>
                table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>loss<span class="token punctuation">,</span>
                table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>GF<span class="token punctuation">,</span>
                table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>GA<span class="token punctuation">,</span>
                table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>score<span class="token punctuation">,</span>
                table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>point_diff<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>To make the .txt file more readable, we can try to mimic a spreadsheet format by using headers to indicate the meaning of the columns' values, a separator between the headers and data, and formatting the data so that it fits into our "spreadsheet" nicely.</p>
<p>This is done by carefully calculating how many characters each field would take, and using the appropriate format specifier accordingly. Each line is printed to <code>fout</code> with the following format:</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code><span class="token string">"| %-4d | %-20s | %4d | %5d | %6d | %12d | %14d | %6d | %15d |\n"</span>
</code></pre><p>These format specifiers have specific lengths assigned to them to accommodate for the width of the headers. For example, to properly align the values, we use <code>%12d</code> for values under "Goals Scored" compared to <code>%4d</code> for values under "Wins". Then, for rank and team names, we add the minus sign in front of the length to tell <code>fprintf()</code>that we want those values to be <strong>aligned left.</strong></p>
<p>Finally, we pass in the values of each member of the <code>i</code>-th team as the last argument for <code>fprintf()</code>. Running J_score1.c, we get the following output in J_score.txt:</p>
<p align="center"> <img class="noshade" src="./assets/output1.png" width="75%"> </p>
<p>We can see that teams are sorted by their points, and teams with tied points are sorted by their goal difference.</p>
<h2 id="3-j_score2c">3. J_score2.c </h2>
<p>Now let's take a look at another approach: <strong>heapsort.</strong> Despite being relatively simple in concept, heapsort is widely used in enterprise, production environments for its performance, efficiency and consistently low memory usage. We need to first understand what a <em>heap</em> is, before we can go into heapsort.</p>
<h3 id="a-what-is-a-heap">a). What is a heap? </h3>
<p>A heap is just a version of a binary tree. A binary tree is a visualization method that takes numbers and treats them as <em>nodes</em>. It is usually visualized with the <em>root</em> of the tree at the top. There is only one root node, and each node branches out into <strong>two</strong> <em>child nodes</em> (hence the name). At the bottom of the tree are the <em>leaf nodes</em>, which don't have child nodes, as they are at the lowest level of the tree. A binary tree is constructed by putting the first element as the root, then the second as the <em>left node</em> of the root, the third as the <em>right node</em> of the root. Then for the third level and so on, we fill the tree <strong>from left to right.</strong> We cannot create a new level before filling up the entire level. This rule conveniently gives us a mathematical representation for their indices as follows:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">F</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mtext>  </mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mtext>  </mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">y</mi><mtext>  </mtext><mi mathvariant="normal">n</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mtext>  </mtext></mrow><mi>i</mi><mrow><mo separator="true">,</mo><mtext>  </mtext></mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">s</mi><mtext>  </mtext><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">t</mi><mtext>  </mtext><mi mathvariant="normal">c</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">d</mi><mtext>  </mtext><mi mathvariant="normal">n</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mtext>  </mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mtext>  </mtext></mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mrow><mtext>  </mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mtext>  </mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">s</mi><mtext>  </mtext><mi mathvariant="normal">r</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">t</mi><mtext>  </mtext><mi mathvariant="normal">c</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">d</mi><mtext>  </mtext><mi mathvariant="normal">n</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mtext>  </mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mtext>  </mtext></mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\mathrm{For\;an\;arbitrary\;node\;} i\mathrm{,\;}
    \mathrm{its\;left\;child\;node\;is\;} 2i+1
    \mathrm{\;and\;its\;right\;child\;node\;is\;} 2i+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">For</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">an</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">arbitrary</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">node</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="mord mathnormal">i</span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="mord"><span class="mord mathrm">its</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">left</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">child</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">node</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">and</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">its</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">right</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">child</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">node</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></span></p>
<br>
<p align="center"> <img src="./assets/binary_tree.png" width="75%"> </p>
<p>When classified by rule, there are two kinds of heaps: the <em>max</em> heap and the <em>min</em> heap. As their name suggests, a max heap has the largest element at the top, and a min heap has the smallest element at the top. Additionally, a max heap respects the heap rule where no child can be <em>larger</em> than its parent, and a min heap respects the rule where no child can be <em>smaller</em> than its parent. In a way, <em>building</em> a min or max heap is already partly sorting the array. However, take a look at the example below, where we have a min heap but when we convert it into an array, it's not fully sorted yet:</p>
<p align="center"> <img src="./assets/min-heap-unsorted.jpeg" width="75%"> </p>
<h3 id="b-building-a-heap">b). Building a heap </h3>
<p>Building min and max heaps is done by repeatedly <em>heapify</em>ing the binary tree. Heapify is in principle, a recursive function. For this explanation, let's say we want to make a min heap. To do this, we iterate from the last non-leaf node (index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{n}{2}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>), and decrement the iterator by 1 until it reaches 0, inclusive. We pass the iterator as the index of the node that heapify should access. Say we have a tree of 7 elements, then we start from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mfrac><mn>7</mn><mn>2</mn></mfrac><mo>−</mo><mn>1</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i = \frac{7}{2} -1 = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>, call heapify on that node, then heapify <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, heapify <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, and by the end we should have a min heap.</p>
<p>First, it takes the root of a tree, compares it to both of its child nodes, and if one of the child nodes is smaller, heapify swaps that child node with the root, making the root now the smallest between the three nodes. Then, heapify recursively calls itself, but now passing the index of the node that used to contain the smallest number. The subtree would then be heapified too, with the smallest element as the parent.</p>
<p align="center"> <img src="./assets/heapify.jpeg" width="75%"> </p>
<p align="center"> click <a href="https://imgur.com/a/GTZ2z2F">here</a> to see full image. </p>
<p>If we see what the array looks like after the min heap is built, we can see that it's <em>somewhat</em> sorted, but not completely. We have the smallest element as the first one, and there seems to be a trend of increasing numbers, but some elements are still out of order.</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>5</th>
<th>4</th>
<th>8</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
</table>
<h3 id="c-heapsort">c). heapsort </h3>
<p>Finally, we can talk about heapsort. The following points outline the principle of heapsort:</p>
<ol>
<li>Obtain min/max heap</li>
<li>Move root from the heap to the sorted portion by swapping it with the last element in the heap</li>
<li>Now the tree is not a heap, so heapify again to obtain min/max heap</li>
<li>Move new root from the heap to the sorted portion by swapping it with the last element in the heap</li>
<li>Repeat until the heap is gone and everything is sorted</li>
</ol>
<p>Perhaps counterintuitively, sorting elements from smallest to largest is done by utilizing the <em>max</em> heap, and sorting from largest to smallest is done by utilizing the <em>min</em> heap. This is because we put the sorted portion <em>after</em> the heap in the array, and when elements are added to the sorted portion, it's added in front of it, which means we're adding elements from the back to front. Take the following example of sorting from smallest to largest:</p>
<p align="center"> <img src="./assets/heapsort.jpeg" width="75%"> </p>
<p>Instead of the heap being an entirely separate array, it's just a representation of the unsorted portion of our array. We sort the array by repeatedly making a max heap, taking the root out and putting it in front of the sorted portion, and repeat until there is no unsorted portion anymore; there is no heap anymore. Then we know that everything inside the array is sorted.</p>
<h3 id="d-applying-heapsort-to-j_score2c">d). Applying heapsort to J_score2.c </h3>
<p>So now we know how we could use heapsort for our case. Since we want to sort the teams from the highest ranking to the lowest, we will need to build <strong>min heaps.</strong> We take the lowest ranked team in the heap, put it at the bottom of our figurative table, and repeat until the table is sorted.</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code><span class="token keyword keyword-void">void</span> <span class="token function">rank_score</span><span class="token punctuation">(</span>SC table<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> SC <span class="token operator">*</span>rank_array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> number_of_teams<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Create array of pointers</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> number_of_teams<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rank_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Build min heap</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> number_of_teams<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>rank_array<span class="token punctuation">,</span> number_of_teams<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*
    At this point in the code, we have built a min heap, which means
    the smallest element is at the top of the heap, and no child node is
    smaller than the parent. However, it's not fully sorted yet.
    */</span>

    <span class="token comment">// Heap sort</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> n <span class="token operator">=</span> number_of_teams <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> n <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*
        Remove root node from heap by swapping with last element
        Then, heapify at root to get the smallest element at the root again
        Repeat until the heap is gone.
        */</span>
        <span class="token function">swap_pointers</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rank_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>rank_array<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">heapify</span><span class="token punctuation">(</span>rank_array<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>To make our algorithm even more efficient, we will use an array of pointers instead of moving entire structs around. This array of pointers is created simply by iterating through the table's length, storing the pointer to each team's data inside an array aptly named <code>rank_array[]</code>. Then, our first min heap is created before the heap sort. The root of this min heap is the smallest element in the array—the lowest ranked team in the league. Once we have this initial min heap, that means we can take out the root, put it into the sorted portion, and run heapify again on the unsorted portion. This is why we start the second <code>for</code> loop in <code>rank_score()</code> at <code>n = number_of_teams - 1</code>, because by the point we need to run <code>heapify()</code> again, we have taken out the root of the first min heap, and the unsorted portion's size has decreased by 1. Once this heapify is done, we will have another min heap, so we <strong>decrement n</strong> by 1 (implying the size of the heap should decrease), take out the root and put it in the sorted portion, and repeat the entire process again.</p>
<p>At a lower level, we construct our heapify function specifically for out case. This amounts to simply putting our <code>if-else</code> ladder in the comparison between child nodes and the parent node:</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code><span class="token keyword keyword-void">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span>SC <span class="token operator">*</span>rank_array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> n<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> lowest <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// Initialize lowest as parent node</span>
    <span class="token keyword keyword-int">int</span> left <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// Index left child node</span>
    <span class="token keyword keyword-int">int</span> right <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// Index right child node</span>
    
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// If left child node should rank lower</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>rank_array<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">-&gt;</span>score <span class="token operator">&lt;</span> rank_array<span class="token punctuation">[</span>lowest<span class="token punctuation">]</span><span class="token operator">-&gt;</span>score<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            lowest <span class="token operator">=</span> left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>rank_array<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">-&gt;</span>score <span class="token operator">==</span> rank_array<span class="token punctuation">[</span>lowest<span class="token punctuation">]</span><span class="token operator">-&gt;</span>score<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>rank_array<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">-&gt;</span>point_diff <span class="token operator">&lt;</span> rank_array<span class="token punctuation">[</span>lowest<span class="token punctuation">]</span><span class="token operator">-&gt;</span>point_diff<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                lowest <span class="token operator">=</span> left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>rank_array<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">-&gt;</span>point_diff <span class="token operator">==</span> rank_array<span class="token punctuation">[</span>lowest<span class="token punctuation">]</span><span class="token operator">-&gt;</span>point_diff<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>rank_array<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">-&gt;</span>GF <span class="token operator">&lt;</span> rank_array<span class="token punctuation">[</span>lowest<span class="token punctuation">]</span><span class="token operator">-&gt;</span>GF<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    lowest <span class="token operator">=</span> left<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// If right child node should rank lower</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>rank_array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">-&gt;</span>score <span class="token operator">&lt;</span> rank_array<span class="token punctuation">[</span>lowest<span class="token punctuation">]</span><span class="token operator">-&gt;</span>score<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            lowest <span class="token operator">=</span> right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>rank_array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">-&gt;</span>score <span class="token operator">==</span> rank_array<span class="token punctuation">[</span>lowest<span class="token punctuation">]</span><span class="token operator">-&gt;</span>score<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>rank_array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">-&gt;</span>point_diff <span class="token operator">&lt;</span> rank_array<span class="token punctuation">[</span>lowest<span class="token punctuation">]</span><span class="token operator">-&gt;</span>point_diff<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                lowest <span class="token operator">=</span> right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>rank_array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">-&gt;</span>point_diff <span class="token operator">==</span> rank_array<span class="token punctuation">[</span>lowest<span class="token punctuation">]</span><span class="token operator">-&gt;</span>point_diff<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>rank_array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">-&gt;</span>GF <span class="token operator">&lt;</span> rank_array<span class="token punctuation">[</span>lowest<span class="token punctuation">]</span><span class="token operator">-&gt;</span>GF<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    lowest <span class="token operator">=</span> right<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// Swap if root is not the largest element, then continue heapify</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>lowest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Swapping pointers around</span>
        <span class="token function">swap_pointers</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rank_array<span class="token punctuation">[</span>lowest<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>rank_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>rank_array<span class="token punctuation">,</span> n<span class="token punctuation">,</span> lowest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="e-pointers-of-pointers">e). Pointers of pointers </h3>
<p>Remember that to swap things in an array, we need their memory address. That's exactly what we're doing with <code>swap_pointers()</code>. We pass the memory address of <code>rank_array[0]</code> and <code>rank_array[n]</code>, which are pointers. This means we're passing <em>pointers to pointers</em>. Although it may seem confusing, we don't actually have to worry since pointers are just plain variables, and exchanging their values are as simple as exchanging the values of any other variable: using the dereference operator (*).</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code><span class="token keyword keyword-void">void</span> <span class="token function">swap_pointers</span><span class="token punctuation">(</span>SC <span class="token operator">*</span><span class="token operator">*</span>pointerA<span class="token punctuation">,</span> SC <span class="token operator">*</span><span class="token operator">*</span>pointerB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// this function swaps pointers. To do that, we pass in the pointer to the pointer.</span>
    SC <span class="token operator">*</span>temp <span class="token operator">=</span> <span class="token operator">*</span>pointerA<span class="token punctuation">;</span>
    <span class="token operator">*</span>pointerA <span class="token operator">=</span> <span class="token operator">*</span>pointerB<span class="token punctuation">;</span>
    <span class="token operator">*</span>pointerB <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>For data types that are not numbers, we have no choice but to use a temp variable to store temporary data for swapping. Since a pointer is typically only 4 bytes, we don't really have to worry about performance here.</p>
<h3 id="f-output-of-j_score2c">f). Output of J_score2.c </h3>
<p>Compiling and running the program, we get an identical result as the one we get from J_score1.c:</p>
<p align="center"> <img class="noshade" src="./assets/output2.png" width="75%"> </p>
<h2 id="4-testing-large-datasets">4. Testing large datasets </h2>
<p>Let's now test just how much more efficient heapsort is compared to selection sort. The effect will not show if we only have 18 teams, but what about a thousand?</p>
<p>I made a rough python script that generates randomized result data of games won, games drawn, games lost, goals scored and goals conceded. I adjusted the ranges, but the data is probably still nonsensical when analyzed closely. However, it will give us a rough estimate of how scaling affects efficiency of sorting algorithms. The python script outputs a file containing the result of a thousand different teams:</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code><span class="token keyword keyword-from">from</span> numpy <span class="token keyword keyword-import">import</span> random
<span class="token keyword keyword-import">import</span> csv

<span class="token keyword keyword-def">def</span> <span class="token function">generate_wdl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    wins <span class="token operator">=</span> <span class="token number">0</span>
    draws <span class="token operator">=</span> <span class="token number">0</span>
    losses <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword keyword-while">while</span> wins <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token keyword keyword-or">or</span> losses <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        wins <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">16.5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        draws <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        losses <span class="token operator">=</span> <span class="token number">33</span><span class="token operator">-</span><span class="token punctuation">(</span>wins<span class="token operator">+</span>draws<span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> wins<span class="token punctuation">,</span>draws<span class="token punctuation">,</span>losses

<span class="token keyword keyword-def">def</span> <span class="token function">generate_goals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    goals_for <span class="token operator">=</span> <span class="token number">0</span>
    goals_against <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword keyword-while">while</span> goals_for <span class="token operator">&lt;</span> <span class="token number">30</span> <span class="token keyword keyword-or">or</span> goals_against <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">:</span>
        goals_for <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        goals_against <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> goals_for<span class="token punctuation">,</span>goals_against

file_path <span class="token operator">=</span> <span class="token string">"J_resultlarge.csv"</span>


result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">6</span> <span class="token keyword keyword-for">for</span> _ <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Team "</span> <span class="token operator">+</span> <span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">{</span>i<span class="token punctuation">}</span></span><span class="token string">"</span></span>
    result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> generate_wdl<span class="token punctuation">(</span><span class="token punctuation">)</span>
    result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> generate_goals<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword keyword-with">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>file_path<span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">"w"</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token keyword keyword-as">as</span> csv_file<span class="token punctuation">:</span>
    csv_writer <span class="token operator">=</span> csv<span class="token punctuation">.</span>writer<span class="token punctuation">(</span>csv_file<span class="token punctuation">)</span>
    csv_writer<span class="token punctuation">.</span>writerows<span class="token punctuation">(</span>result<span class="token punctuation">)</span>
</code></pre><p>Then I created a copy of J_score1.c and J_score2.c, changed their input file to J_resultlarge.csv and output files to J_scorelarge1.txt and J_scorelarge2.txt respectively. Finally, I modified the files to include a stopwatch that tracks how long it takes each program to sort the teams.</p>
<p>In J_scorelarge1.c:</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code><span class="token keyword keyword-void">void</span> <span class="token function">rank_score</span><span class="token punctuation">(</span>SC table<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> number_of_teams<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">clock_t</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>
    <span class="token keyword keyword-double">double</span> elapsed<span class="token punctuation">;</span>
    start <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// SORTING CODE</span>
    end <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    elapsed <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> CLOCKS_PER_SEC<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[DEBUG] %lf seconds elapsed\n"</span><span class="token punctuation">,</span>elapsed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>and in J_scorelarge2.c:</p>
<pre data-role="codeBlock" data-info="C" class="language-c C"><code><span class="token keyword keyword-void">void</span> <span class="token function">rank_score</span><span class="token punctuation">(</span>SC table<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> SC <span class="token operator">*</span>rank_array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> number_of_teams<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">clock_t</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>
    <span class="token keyword keyword-double">double</span> elapsed<span class="token punctuation">;</span>
    start <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// SORTING CODE</span>
    end <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    elapsed <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> CLOCKS_PER_SEC<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[DEBUG] %lf seconds elapsed\n"</span><span class="token punctuation">,</span>elapsed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>Running the two one after another:</p>
<p align="center"> <img class="noshade" src="./assets/difference.png" width="75%"> </p>
<p>Yes, heapsort was almost an entire <strong>order of magnitude</strong> faster than selection sort. And this is only for a dataset <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mi mathvariant="normal">B</mi><mo>∗</mo><mn>1000</mn><mo>=</mo><mn>32</mn><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">B</mi></mrow></mrow><annotation encoding="application/x-tex">32\mathrm{B} * 1000 = 32\mathrm{KB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">32</span><span class="mord mathrm">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">32</span><span class="mord"><span class="mord mathrm">KB</span></span></span></span></span> large. Real databases are much, much larger—a typical database containing user data of a medium-sized website would range between a few gigabytes to tens of gigabytes. Using an inefficient data structure that "just works" is <strong>not</strong> an option when we're working with files this large.</p>
<style>
    figcaption{
        text-align:center;
        font-size:9pt
    }
    img{
        filter: drop-shadow(0px 0px 7px );
    }
    .noshade{
        filter: none
    }
    .disclaimer{
        font-size: 9pt
    }
    .linker{
        color: inherit !important
    }
</style>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>