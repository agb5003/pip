# Exercise 6-4: file_open.c

As briefly mentioned in a previous report, opening a file can be done using the `fopen()` function defined in `<stdio.h>`. 

```C
#include <stdio.h>

int main() {
    FILE *fp;

    fp = fopen("sample.txt","r");
    if( fp == NULL) {
        printf("Can't open file.\n");
        return 1;
    }
    else
    printf("success\n");
    fclose(fp);
    return 0;
}
```

to open a file, we must first define a file pointer. Note that this kind of pointer is different from pointers previously discussed. `FILE *fp` and `int *px` are different kinds of pointers, because here `*fp` is a *file pointer*, not a *variable pointer*. A file pointer contains information about where the file is located on the storage device (without specifying relative or absolute directories, it would be in the same working directory as the binary/executable), while a variable pointer contains the memory address of a variable, i.e., the location of a variable on the RAM device. A common misconception is that when `fopen()` is ran, it copies the file to the RAM for reading and writing, but this is incorrect. `fopen()` simply collects information about where a file is stored on the storage device, and the file won't be copied to the RAM unless it's later explicitly read or written to.

## `fopen()` syntax

To use `fopen()`, the syntax is as follows:

```C
file_pointer = fopen("filepath", "am");
```

where `filename` is the file path (<a class=linker name="which-includes">which includes its name</a> following the directory path, if specified) of the file to open, and `am` is the file access mode (also called file access *flags*).

| File access mode string | Meaning | Explanation | Action if file already exists | Action if file does not exist |
| - | - | - | - | - |
"r" | read | Open a file for reading | read from start | failure to open |
|"w" | write | Create a file for writing | **destroy contents** | create new |
| "a" | append | Append to a file | write to end | create new |
| "r+" | read extended | Open a file for read/write | read from start | error |
| "w+" | write extended | Create a file for read/write | **destroy contents** | create new |
| "a+" | append extended | Open a file for read/write | write to end | create new |

These file access flags are essentially modes in which the program interacts with the file. Notice that *write* mode is essentially just for creating new files, because it overwrites any existing data. In order to *add* to a file instead, the *append* mode should be used. These file access flags are crucial as they determine what we can and can't do with the file later in the program.

## Relational and absolute paths, and their use in `fopen()`

Earlier, I said that in addition to opening files in the same folder (*cwd* - current working directory) as the binary/executable program, the program can also interact with files outside of it and in subfolders inside it. This is done through relational and absolute file paths. As their name suggests, they are two different ways to access files in the storage system: relational file paths work by specifying the position of the file *in relation to* where the binary is located. Absolute file paths work by specifying the location of the file in relation to the *root* of the file system.

### Absolute file paths

To use the absolute path of a file or directory, the first character in the string of directories should be the *path separator*. This path separator depends on which operating system is installed on the storage system. On [UNIX-like operating systems](https://www.wikiwand.com/en/Unix-like) like macOS and Linux, the path separator is the single forward slash ('/'). On Windows, it's a backslash ('\\'). The next directory would then be a folder inside the root folder, for example, perhaps "Users" on macOS and Windows, or "home" on Linux. Usually, "Users" and "home" would be followed by the user folders, for example, mine is called "max", then this folder contains folders that we are more familiar with - Desktop, Documents, Pictures, etc., created by the operating system to facilitate basic organization of our files.

#### The Windows catch

Although it's technically correct that the root of a Windows filesystem is the path separator backslash ('\\'), using this inside `fopen()` might not work. This is because Windows utilizes *drive letters*. The drive letters A: and B: are reserved for floppy disk drives (they were still very much in common use when the operating system was created), so almost all Windows systems will have the operating system itself installed on the C: drive. Then, drive letters D:, E:, F: and so on can be added by the user after installation for storage purposes. An example absolute file path would then look like this on Windows:

C:\Users\max\repos\pip\lec06\ex6-4\ex6-4.md

#### Files stored in other drives (or partitions)

External storage devices, like hard drives and USB flash drives, are [*mounted*](https://www.wikiwand.com/en/Mount_(computing)) to a subfolder somewhere in the root folder, so that it can be accessed by the user or programs. In computers with multiple drives, the operating system is installed in only one of these drives, and if other drives are to be used for storage purposes, they can be *mounted* to a subfolder inside the drive where the operating system is installed, and this gives the user and programs on the operating system access to the files in those other drives. In most personal computers (and certainly for Windows and macOS systems), these external drives are automatically configured by the OS to *automount* on start up, so the user won't have to worry about mounting the drives before accessing the files on them.






[comment]: <> (Below is CSS code for the output HTML and pdf files. Don't touch them unless you know what you're doing.)
<style>
    figcaption{
    text-align:center;
        font-size:9pt
    }
    img{
        filter: drop-shadow(0px 0px 7px );
    }
    .noshade{
        filter: none
    }
    .linker{
        color: inherit !important;
    }
</style>